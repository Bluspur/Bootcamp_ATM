Abstract Type that defines most of the behaviour for a bank account. Most behaviour is the same, but the amount of overdraft varies.
___
### Fields
- AccountID
- OverdraftLimit
- Balance

### <u>1.4.2023</u>
Started planning how the Account class should be represented in code. At the most basic level, it needs to have some kind of field to represent the current balance. I wanted to make sure that I picked the best datatype for representing money early on. An article at https://adevait.com/java/java-data-types recommends the usage of BigDecimal as the preferred way of handling currency, so I have opted to use that for now, further backed up the oracle documentation at https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html. 
Something I noticed as I went along with `BigDecimal` is that when instantiating values, mostly in tests right now, is that the compiler is really insistent that the best thing to pass in is actually a string representation of the number I want. So it thinks that "1234.56" is superior to 1234.56d. The documentation suggests this is to do with floating point errors, and I have no reason to doubt the compiler on this, so I'm following its lead for now. It might turn out to be a benefit later when it comes to polling user input.
Started working in a TDD way on a test that constructs a new `Account` object with default values and calls a method called `getBalance()` which should return 0. At the time, I literally just had the `getBalance()` method return a new `BigDecimal` with a value of 0. Moving on, I made a test for constructing an `Account` with an initial balance. I realised after the fact that this wasn't actually in the brief, but I've kept it in for now, since I can always remove it later. Regardless, it meant that I could instantiate an `Account` with a starting value, and use the `getBalance()` method to check that it was initialized properly. Obviously this meant changing the `getBalance()` method. The simplest solution was having an `Account` member: `BigDecimal balance`, that I could assign the initial value to, this also meant going back to the parameterless constructor and making sure to initialize `balance` to 0.
Now that I had a working value to represent the account balance, I needed to be able to add and subtract funds. I started with the test for adding funds; this was actually pretty easy to do in a TDD way by now, as once I let IntelliJ fill in the missing `addFunds()` method, I could complete the test to the assertion, then work on making the actual method do what was necessary. In this case I needed to use the `BigDecimal.add()` method since it doesn't overload the + operator. Once that was done, then the test passed and behaved as expected. Subtraction was essentially the same test and the same method (possibility to refactoring?) but using the `BigDecimal.subtract()` method instead. It was quickly working happily.
Despite everything working, I wanted to clear up the scenario of negative numbers being used in the `addFunds()` and `subtractFunds()` methods. While they would both function perfectly fine with negative numbers, just doing the opposite of their name, I wanted to avoid the confusion of `addFunds()` actually taking funds away from the balance. To this end, I wrote a test for the `addFunds()` method that it should throw an IllegalArgumentException if passed a negative value. Getting the test to pass was a simple as a quick if-statement that uses the `BigDecimal` signum method to check if the number is negative and if it is, then throw the relevant exception with a quick message. I then wanted to add the same test and check to the `subtractFunds()` method, but rather than writing out the if-statement check again, I moved the if-statement to its own private method, to reduce repetition and make it clear via the method name, what that check was for.
I still need to add the overdraft limits, and probably also a check on the subtract method to make sure that the balance cannot drop below that limit, or something similar, I'm not sure exactly how an account would handle that? I guess it could actually drop below, and you'd start paying big fees or there'd be some consequence? There's not really enough information in the brief to confidently say what the behaviour should be.

### <u>6.4.2023</u>
Simple day with the goal of implementing the functionality surrounding account overdrafts. I started with an arbitrary overdraft limit of 1000. The first step was to create an if check in the `subtractFunds()` method. It needs to check if the balance after subtracting the funds is less than `0 - overdraftLimit`, which was simple enough to create if a little ugly looking using `BigDecimal` comparison. Then I needed to decide what to do if the balance would exceed the overdraft. Given that this is some sort of ATM, I opted to simply not allow it for now. Going beyond your overdraft will throw a custom managed exception. So it can be handled elsewhere in the program, this should allow for things like on-screen error messages, or simply logging to the console.
The next step was deciding how to implement the different overdraft values for their relevant account types. My initial thought on this problem was that it would make sense to purely use inheritance. So that `Account` would be abstract, and I'd have three classes that implement `Account`: `SmallBusinessAccount`, `CommunityAccount`, and `ClientAccount`. This works fine, but because I am using `BigDecimal`, it is hard to initialize the overdraft value before it passes the value to the `Account` constructor, plus it makes the overdraft value look like a magic number. So I decided to also create an enum type called `AccountType` which has the method `getOverdraftLimit()` which returns the overdraft value as a BigDecimal. Maybe it is slightly too complicated, but it works and all tests are still passing, so I am going to leave it for now unless I can think of a better way.

### <u>6.4.2023</u>
The way the Account class has changed a lot since my last entry. While I was initially working with a single abstract `Account` type that had three implementations, I found that to be overly cumbersome given that the only difference between the types was the overdraft limit. So instead I opted to consolidate them back into a single `Account` class. The way I opted to handle the type was to introduce a new Enum called `AccountType`. It contains the three specified types, has a method to get the overdraft limit using a simple switch statement, and even allowed me to have a simple parser for converting a string value into an `AccountType` which was useful for use with the terminal.