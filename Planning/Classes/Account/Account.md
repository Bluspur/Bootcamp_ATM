Abstract Type that defines most of the behaviour for a bank account. Most behaviour is the same, but the amount of overdraft varies between classes.
___
### Fields
- AccountID
- OverdraftLimit
- Balance

### <u>1.4.2023</u>
Started planning how the Account class should be represented in code. At the most basic level, it needs to have some kind of field to represent the current balance. I wanted to make sure that I picked the best datatype for representing money early on. An article at https://adevait.com/java/java-data-types recommends the usage of BigDecimal as the preferred way of handling currency, so I have opted to use that for now, further backed up the oracle documentation at https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html. 
Something I noticed as I went along with `BigDecimal` is that when instantiating values, mostly in tests right now, is that the compiler is really insistent that the best thing to pass in is actually a string representation of the number I want. So it thinks that "1234.56" is superior to 1234.56d. The documentation suggests this is to do with floating point errors, and I have no reason to doubt the compiler on this, so I'm following its lead for now. It might turn out to be a benefit later when it comes to polling user input.
Started working in a TDD way on a test that constructs a new `Account` object with default values and calls a method called `getBalance()` which should return 0. At the time, I literally just had the `getBalance()` method return a new `BigDecimal` with a value of 0. Moving on, I made a test for constructing an `Account` with an initial balance. I realised after the fact that this wasn't actually in the brief, but I've kept it in for now, since I can always remove it later. Regardless, it meant that I could instantiate an `Account` with a starting value, and use the `getBalance()` method to check that it was initialized properly. Obviously this meant changing the `getBalance()` method. The simplest solution was having an `Account` member: `BigDecimal balance`, that I could assign the initial value to, this also meant going back to the paramtereless constructor and making sure to initialize `balance` to 0.
Now that I had a working value to represent the account balance, I needed to be able to add and subtract funds. I started with the test for adding funds; this was actually pretty easy to do in a TDD way by now, as once I let IntelliJ fill in the missing `addFunds()` method, I could complete the test to the assertion, then work on making the actual method do what was necessary. In this case I needed to use the `BigDecimal.add()` method since it doesn't overload the + operator. Once that was done, then the test passed and behaved as expected. Subtraction was essentially the same test and the same method (possibility to refactoring?) but using the `BigDecimal.subtract()` method instead. It was quickly working happily.
Despite everything working, I wanted to clear up the scenario of negative numbers being used in the `addFunds()` and `subtractFunds()` methods. While they would both function perfectly fine with negative numbers, just doing the opposite of their name, I wanted to avoid the confusion of `addFunds()` actually taking funds away from the balance. To this end, I wrote a test for the `addFunds()` method that it should throw an IllegalArgumentException if passed a negative value. Getting the test to pass was a simple as a quick if-statement that uses the `BigDecimal` signum method to check if the number is negative and if it is, then throw the relevant exception with a quick message. I then wanted to add the same test and check to the `subtractFunds()` method, but rather than writing out the if-statement check again, I moved the if-statement to its own private method, to reduce repitition and make it clear via the method name, what that check was for.
I still need to add the overdraft limits, and probably also a check on the subtract method to make sure that the balance cannot drop below that limit, or something similar, I'm not sure exactly how an account would handle that? I guess it could actually drop below and you'd start paying big fees or there'd be some consequence? There's not really enough information in the brief to confidently say what the behaviour should be.